---
title: "Wavelets"
output: html_notebook
---


```{r}
library(WaveletComp)
library(tidyverse)
library(lubridate)
library(glue)
```

[WaveletComp](http://www.hs-stat.com/projects/WaveletComp/WaveletComp_guided_tour.pdf)

```{r}
gold <- read_csv("data/GOLD_1791-2018.csv",skip = 3)
gdp <- read_csv("data/USGDP_1790-2018.csv", skip=2)
wage <- read_csv("data/USWAGE_1774-2018.csv", skip=3)

gdp_in_gold <- left_join(gold, gdp, by = "Year") %>% 
  transmute(value = `Nominal GDP per capita (current dollars)`/`New York Market Price (U.S. dollars per fine ounce)`,
         date = parse_date_time(Year,"y")) 
wg_in_gold <- wage %>% 
  filter(Year>=1900) %>% 
  left_join(gold, gdp, by = "Year") %>% 
  transmute(value =`Production Workers Hourly Compensation (nominal dollars)`/`New York Market Price (U.S. dollars per fine ounce)`,
            date = parse_date_time(Year,"y")) %>%
  na.omit()

```


```{r message=FALSE, warning=FALSE}
wage_wavelet <- analyze.wavelet(my.data = wg_in_gold,
                                my.series = "value",
                                date.format = "%Y-%m-%d",
                                date.tz = "UTC", verbose = F)

```

```{r}

png("plots/espectograma_wg.png", width = 1600, height = 1000, units = "p", pointsize = 40)
wt.image(wage_wavelet,color.key = "q", show.date = TRUE,
         label.time.axis = TRUE,
         plot.legend = FALSE,
         main = "Espectograma salario en oro")

dev.off()
```

log wage


```{r message=FALSE, warning=FALSE}
wage_wavelet <- wg_in_gold %>% 
  mutate(logvalue = log(value,base = 10)) %>% 
  analyze.wavelet(my.data = .,
                  my.series = "logvalue",
                  date.format = "%Y-%m-%d",
                  date.tz = "UTC", verbose = F)


png("plots/espectograma_log_wg.png", width = 1600, height = 1000, units = "p", pointsize = 40)
wt.image(wage_wavelet,color.key = "q", show.date = TRUE,
         label.time.axis = TRUE,
         plot.legend = FALSE,
         main = "Espectograma salario en log(oro)")

dev.off()

```


```{r}

gdp_wavelet <- analyze.wavelet(my.data = gdp_in_gold,
                                my.series = "value",
                                date.format = "%Y-%m-%d",
                                date.tz = "UTC")

png("plots/espectograma_gdp.png", width = 1600, height = 1000, units = "p", pointsize = 40)
wt.image(gdp_wavelet,color.key = "q",
         show.date = TRUE,
         plot.legend = FALSE,
         label.time.axis = TRUE,
         main = "Espectograma PBI en oro")
dev.off()

```


Hago algunas pruebas para ver como se verían señales puras:


### Escala log


```{r}

gdp_wavelet <- gdp_in_gold %>%
  mutate(logvalue = log(value,base = 10)) %>% 
  analyze.wavelet(my.data = .,
                  my.series = "logvalue",
                  date.format = "%Y-%m-%d",
                  date.tz = "UTC")  

png("plots/espectograma_log_gdp.png", width = 1600, height = 1000, units = "p", pointsize = 40)

wt.image(gdp_wavelet,color.key = "q",
         periodlab="Frecuencia de ciclo",
         label.period.axis =TRUE,
         plot.legend = FALSE,
         spec.period.axis = list(at = c(3,7,20,50), labels = TRUE),
         n.levels = 100,
         show.date = TRUE,
         label.time.axis = TRUE, 
         main = "Espectograma log(PBI en oro)")
dev.off()

```


observaciones:

- En escala logarítima se reduce la heterocedasticidad de la serie, y sue puede observar los ciclos en un período más extendido del tiempo. especialmente el de 50 años
- Más allá de que hasta el 1900 la serie no tenga demasiada información, si filtarmos para quedarnos sólo con el último siglo, se perdería resolución y no se podría ver el ciclo de 50 años.

construyo el _modelo teórico_ de una economía cíclica con que se construye a partrir de:


![periodo y amplitud](https://www.mathsisfun.com/algebra/images/period-amplitude.svg)

- un cambio de nivel (cte)
- Una tendencia (x0)
- Un ciclo corto (de periodo de 3 años y amplitud 10)
- Un ciclo medio (de periodo de 10 años y amplitud 20)
- Un ciclo largo (de periodo de 50 años y amplitud 30)
- Ruido normal

```{r}
nn = 1000
#cambio_nivel
impulso= c(rep(50,(nn/2-1)),100,rep(50,nn/2))
x0 = ts(c(1:nn)/2)
x3 = ts(10*sin((2*pi/3)*c(1:nn)))
x10 = ts(20*sin((2*pi/10)*c(1:nn)))
x50 = ts(30*sin((2*pi/50)*c(1:nn)))
ruido <- rnorm(nn)
x = impulso+ x0+  x3 + x10 + x50+ruido


df <- data_frame(periodo=1:nn,impulso=impulso,tendencia=x0, ciclo_3=x3,ciclo_10=x10, ciclo_50=x50,ruido, composicion_series=x)

df %>%
  filter(periodo %in% c(450:550)) %>% 
  gather(componente,valor,2:8,factor_key=T) %>% 
  ggplot(.,aes(periodo,valor))+
  geom_line()+
  labs(title= "Elementos de la serie teórica")+
  facet_wrap(~componente, scales="free")+
  theme_minimal()

ggsave("plots/serie_teorica.PNG")


```


Ahora grafico los wavelets de cada componente y la composición.

```{r message=FALSE, warning=FALSE}

analyze_and_save <- function(var){
  png(glue("plots/espectograma_teorico_{var}.png"), width = 1600, height = 1000, units = "p", pointsize = 40)
  analyze.wavelet(my.data = df,
                my.series = var,
                verbose = F) %>%
  wt.image(.,color.key = "q",periodlab = "Largo del ciclo",timelab = "Tiempo calendario",
           plot.legend = FALSE)
  dev.off()
}


variables <- c("impulso","tendencia", "ciclo_3","ciclo_10", "ciclo_50","ruido", "composicion_series")


for (var in variables) {
  analyze_and_save(var)
}


```

- _cte_, que representa un cambio de nivel en 500, muestra todas las frecuencias de onda sobre la vertical en el punto de cambio de nivel. 
- La tendencia no se puede representar bien en el espectograma, porque el comportamiento ciclico es nulo. La diferencia con el ruido es que pasa de valores de intensidad más bajos al principio del período y tiempo (los ejes) a valores más altos. El ruido normal muestra mayores valores en las frecuencias mas altas (los periodos más bajos).
- Cada uno de los 3 componentes cíclicos se representa a la altura  de su period ()
- La amplitud del ciclo se representa con la intensidad (representado en la escala cromática)


La resolución del espectograma depende de la cantidad de observaciones

```{r message=FALSE, warning=FALSE}
nn = 25
cte= rep(100,nn)
x0 = ts(c(1:nn)/2)
x3 = ts(10*sin((2*pi/3)*c(1:nn)))
x10 = ts(20*sin((2*pi/10)*c(1:nn)))
x50 = ts(30*sin((2*pi/50)*c(1:nn)))
x = cte+ x0+  x3 + x10 + x50

df <- data_frame(period=1:nn,cte=cte,x0=x0, x3=x3,x10=x10, x50=x50, x=x)


```



- En x10 se ve que cuando el ciclo es demasiado grande respecto a la cantidad de observaciones, se satura en la parte superior de _period_


